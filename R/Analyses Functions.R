



#' Build analysis structure
#'
#' Generates a structure in which analyses can be performed and results can be stored
#' @param name A name for the analysis environment. Default is NULL
#' @param HF Maximum limit of the HF band to be used in the analyses. Default is 0.4 Hz
#' @param LF Maximum limit of the LF band to be used in the analyses. Default is 0.15 Hz
#' @param VLF Maximum limit of the VLF band to be used in the analyses. Default is 0.04 Hz
#' @param wv A wavelet to be used for the analyses. Default is d4
#' @param coh A coherence threshold to be used for the analyses. Default is 0.5
#' @param dj A frequency resolution to be used for the analyses. Default is 1/20
#' @param use.weight Boolean, should a Gaussian function be used in the analyses? Default is TRUE.
#' @param use.coherence Boolean, should a coherence threshold be used in the analyses? Default is TRUE.
#'
#' @return A list containing the generated environment for the analyses
#'
#' @details This function allows users to create environments to organize complex analyses and store
#' their results.
#' @author Alvaro Chao-Ecija
#' @export
#'
#' @examples
#' # ADD EXAMPLE!
BuildStructure <- function(name = NULL, HF = 0.4, LF = 0.15, VLF = 0.04, wv = "d4",
   coh = 0.5, dj = 1/20, use.weight = FALSE, use.coherence = TRUE){
              Framework <- list()
              if(is.null(name)) name <- "BRS Study"
              Framework$Name <- name
              Framework$Date <- date()
              Framework$"General Data" <- list()
              Framework$"General Data"$HF <- HF
              Framework$"General Data"$LF <- LF
              Framework$"General Data"$VLF <- VLF
              Framework$"General Data"$Wavelet <- wv
              Framework$"General Data"$Coherence <- coh
              Framework$"General Data"$dj <- dj
              Framework$"General Data"$Weight <- use.weight
              Framework$"General Data"$Threshold <- use.coherence
              Framework$n <- 0
              Framework$Analyses <- list()
              Framework$Controls <- list()
              Framework$BRS <- list()
              Framework$ExpectedVals <- list()
              Framework$Tests <- list()
              Framework$TestsHRV <- list()
              Framework$Clinical <- list()
              class(Framework) <- "WaveletBRS"
              return(Framework)
}



SetAsControl <- function(framework, index, remove  = TRUE, name = NULL){
              N <- length(framework$Controls)
              length(framework$Controls) <- N + 1
              analysis <- framework$Analyses[[index]]
              framework$Controls[[N + 1]] <- analysis
              if(!is.null(name)) framework$Controls[[N + 1]]$Name <- name
              if(remove){
                 framework$Analyses[[index]] <- NULL
                 framework$n <- framework$n - 1
              }
              return(framework)
}


#' Add analysis
#'
#' Add a new analysis to an analysis environment.
#' @param framework An analysis environment generated by \link[WaveletPhysiology]{BuildStructure}
#' @param name A name for the analysis to be added. Default is NULL
#'
#' @return The original analysis environment with a new analysis slot
#' @author Alvaro Chao-Ecija
#'
#' @export
#'
#' @examples
#' # ADD EXAMPLE!
AddAnalysis <- function(framework, name = NULL){
  N <- length(framework$Analyses)
  length(framework$Analyses) <- N + 1
  output <- list()
  output$Date <- date()
  output$Index <- N + 1
  if(is.null(name)) name <- paste("Analysis", N + 1)
  output$Name <- name
  output$BRS <- output$HRV <- output$Data <- list()
  output$BRS$CWT <- output$BRS$DWT <- list()
  framework$Analyses[[N + 1]] <- output
  framework$n <- framework$n + 1
  return(framework)
}


#' Show indexes
#'
#' Show indexes regarding a specific analysis environment.
#' @param framework An analysis environment generated by \link[WaveletPhysiology]{BuildStructure}
#' @param type Type of index to be shown
#'
#' @return A matrix containing the indexes to be shown
#' @author Alvaro Chao-Ecija
#'
#' @export
#'
#' @examples
#' # ADD EXAMPLE!
ShowIndexes <- function(framework, type = c("analyses", "controls", "intervals", "tests")){
              type = match.arg(type)
              if(type == "analyses"){
                 data <- framework$Analyses
              } else if(type == "controls"){
                 data <- framework$Controls
              } else if(type == "intervals"){
                 data <- framework$ExpectedVals
              } else if(type == "tests"){
                  data <- framework$Tests
              }
              N <- length(data)
              output <- matrix(0, ncol = N, nrow = 2)
              for(n in 1:N){
                  output[2,n] <- data[[n]]$Name
              }
              output[1,] <- 1:N
              output <- data.frame(output)
              rownames(output) <- c("Index", "Name")
              colnames(output) <- rep("", N)
              return(output)
}



#' Add data to analysis
#'
#' Add data to a previously generated analysis slot.
#' @param framework An analysis environment generated by \link[WaveletPhysiology]{BuildStructure}
#' @param index An index indicating which analysis slot needs to be used
#' @param RR A vector with RR data
#' @param SBP A vector with systolic blood pressure data
#' @param time A vector of time values
#'
#' @return The original analysis environment, in which new data has been placed in the chosen
#'          analysis slot.
#'
#' @author Alvaro Chao-Ecija
#' @export
#'
#' @examples
#' # ADD EXAMPLE!
AddDataToAnalysis <- function(framework, index, RR, SBP, time){
           framework$Analyses[[index]]$Data <- cbind(Time = time,
             RR = RR, SBP = SBP)
           return(framework)
}

#' Analyze baroreflex sensitivity
#'
#' Computes the baroreflex transfer function from data located in an analysis environment.
#' @param framework An analysis environment generated by \link[WaveletPhysiology]{BuildStructure}
#' @param index An index indicating which analysis slot needs to be used
#' @param method Which method to be used to estimate the transfer function. Default is both.
#'
#' @return The original analysis environment, in which baroreflex sensitivity has been estimated
#'         from the chosen data
#'
#' @author Alvaro Chao-Ecija
#' @export
#'
#' @examples
#' # ADD EXAMPLE!
AnalyzeTransferFun <- function(framework, index, method = c("both", "dwt", "cwt")){
           method <- match.arg(method)
           Data <- ExtractDataFromAnalysis(framework, index)
           if(method == "dwt"){
              tf <- TransferFunDWT(Data$Data, Data$HF, Data$LF, Data$VLF,
                wv = Data$Wavelet, hrv = TRUE)
              framework <- AddTFtoAnalysis(framework, tf, index)
           } else if(method == "cwt"){
              tf <- TransferFunCWT(Data$Data, Data$HF, Data$LF, Data$VLF,
                Data$dj, diff(Data$Data[,1])[1])
              framework <- AddTFtoAnalysis(framework, tf, index)
           } else if(method == "both"){
              tf_dwt <- TransferFunDWT(Data$Data, Data$HF, Data$LF, Data$VLF,
                wv = Data$Wavelet, hrv = TRUE)
              tf_cwt <- TransferFunCWT(Data$Data, Data$HF, Data$LF, Data$VLF,
                                       Data$dj, diff(Data$Data[,1])[1])
              framework <- AddTFtoAnalysis(framework, tf_dwt, index)
              framework <- AddTFtoAnalysis(framework, tf_cwt, index)
           }
           return(framework)
}

#' Add averaged transfer function calculated from the CWT
#'
#' Computes a vector of the frequency averaged transfer function values previously obtained from a
#' CWT transfer function in an analysis environment.
#' @param framework An analysis environment generated by \link[WaveletPhysiology]{BuildStructure}
#' @param index An index indicating which analysis slot needs to be used
#'
#' @return The original analysis environment, in which the averaged CWT transfer function has been added
#'         to a specific analysis slot.
#' @author Alvaro Chao-Ecija
#'
#' @export
#'
#' @examples
#' # ADD EXAMPLE!
AddAvgCwtData <- function(framework, index){
  tf <- AssembleCwtTransferFun(framework, index)
  framework$Analyses[[index]]$BRS$AvgCWT <- list()
  framework$Analyses[[index]]$BRS$AvgCWT <- GetAvgCwtBands(tf)
  return(framework)
}







#' Plot analyzed transfer function
#'
#' Plots an already computed transfer function from a specific analysis in an analysis environment.
#' @param framework An analysis environment generated by \link[WaveletPhysiology]{BuildStructure}
#' @param index An index indicating which analysis slot needs to be used
#' @param method Which method to be used to plot the transfer function.
#' @param time_col Color used to highlight a specific time interval. Default is brown
#' @param HFcolor Color to be used to highlight the HF band
#' @param LFcolor Color to be used to highlight the LF band
#' @param time_flags A vector containing the minimum and maximum limits of a time interval, in minutes.
#'                   Default is NULL.
#' @param use.coherence Boolean, should a coherence threshold be used in the analyses? Default is TRUE.
#' @param nfreqs Number of frequencies to be used. Default is 7
#' @param tem Boolean, creates a temporal file for the plot. Default is FALSE
#' @param newPlot Boolean, generates a new plot without overwriting a previous plot. Default is TRUE
#' @param plotHF Boolean, plot results form the HF band. Default is TRUE
#' @param plotLF Boolean, plot results from the LF band. Default is TRUE
#' @param thr Coherence threshold to be used for the plot. Default is NULL
#'
#' @return None
#'
#' @author Alvaro Chao-Ecija
#'
#'
#' @export
#'
#' @examples
#' # ADD EXAMPLE!
PlotAnalyzedTF <- function(framework, index, method = c("dwt", "cwt", "cwt.avg", "cwt.phase"),
  time_col = "brown", HFcolor = "yellow",
    LFcolor = "green", time_flags = NULL,
       use.coherence = TRUE, nfreqs = 7, tem = FALSE, newPlot = TRUE, plotHF = TRUE, plotLF = TRUE,
  thr = NULL, coupling_index  = 1){
           if(newPlot) x11(title = paste("Transfer Function from",
              framework$Analyses[[index]]$Name))
           #if(dev.cur() > 1) dev.off()
           method <- match.arg(method)
           Data <- ExtractDataFromAnalysis(framework, index)
           if(is.null(thr)) thr <- Data$Coh
            if(method == "dwt"){
              tf <- framework$Analyses[[index]]$BRS$DWT
              tf$Time <- Data$Data[,1]
              im <- PlotTransferFunDWT(tf, time_flags, col = time_col, tem = tem, plotHF = plotHF,
                                       plotLF = plotLF)
              return(im)
           } else if(method == "cwt"){
              tf <- AssembleCwtTransferFun(framework, index)
              im <- PlotCwtTransferFun(tf, thr, use.coherence,
               time_flags = time_flags, tem = tem)
           } else if(method == "cwt.avg"){
             #tf <- framework$Analyses[[index]]$BRS$AvgCWT
             tf <- AssembleCwtTransferFun(framework, index)
             tf <- SplitByCoherence(tf, thr = thr)
             tf$Time <- Data$Data[,1]
             im <- PlotTransferFunDWT(tf, time_flags, col = time_col, tem = tem, plotHF = plotHF,
                                      plotLF = plotLF)
             return(im)
           } else if(method == "cwt.phase"){
             tf <- AssembleCwtTransferFun(framework, index)
             tf <- SplitByCoherence(tf, thr = thr, use.phase = TRUE)
             tf$Time <- Data$Data[,1]
             im <- PlotTransferFunDWT(tf, time_flags, col = time_col, tem = tem, plotHF = plotHF,
                                      plotLF = plotLF)
             return(im)
           }

           if(tem){
              return(im)
           }
}

#' @export
PlotAnalyzedHRV <- function(framework, index,
                           time_col = "brown", HFcolor = "yellow",
                           LFcolor = "green", time_flags = NULL,
                          tem = FALSE, plotHF = TRUE, plotLF = TRUE, newPlot = TRUE){
  if(newPlot) x11(title = paste("Transfer Function from",
                                framework$Analyses[[index]]$Name))
  #if(dev.cur() > 1) dev.off()
  Data <- ExtractDataFromAnalysis(framework, index)
  hrv <- framework$Analyses[[index]]$HRV
  hrv$Time <- Data$Data[,1]
  im <- PlotHRV(hrv, time_flags, col = time_col, tem = tem, plotHF = plotHF,
                             plotLF = plotLF)
    return(im)
}




#' Add time interval
#'
#' Adds a certain time interval cathegory to the structure, so that estimates can be obteined from it.
#' @param framework An analysis environment generated by \link[WaveletPhysiology]{BuildStructure}
#' @param index An index indicating which analysis slot needs to be used
#' @param name An optional name for the interval. The default is NULL
#' @param use_default Use the default variables from "General Data".
#' @param use.coherence Boolean, should a coherence threshold be used in the analyses? Default is TRUE.
#' @param use.weight Boolean, should a Gaussian function be used in the analyses? Default is TRUE.
#'
#'
#' @return A framework with the new additional interval.
#'
#' @details This function allows users to add new time segments to their study environments.For example, it
#'          allows users to define a control interval and a stimulation interval for their study.
#' @author Alvaro Chao-Ecija
#' @export
#'
#' @examples
#' # ADD EXAMPLE!
AddTimeInterval <- function(framework, name = NULL,
   use.default = TRUE, use.coherence = TRUE, use.weight = FALSE){
                            output <- list()
                            N <- length(framework$ExpectedVals)
                            length(framework$ExpectedVals) <- N + 1
                            output$Index <- N + 1
                            if(is.null(name)) name <- paste("Interval", N + 1)
                            output$Name <- name
                            if(use.default){
                               output$Weight <- framework$"General Data"$Weight
                               output$Threshold <- framework$"General Data"$Threshold
                            } else {
                               output$Weight <- use.weight
                               output$Threshold <- use.coherence
                            }
                            output$Time_DWT <- list()
                            output$Time_CWT <- list()
                            output$HR <- list()
                            output$SBP <- list()
                            output$DWT <- list()
                            output$CWT <- list()
                            framework$ExpectedVals[[output$Index]] <- output
                            if(length(framework$ExpectedVals) > 0){
                              framework <- PrepareIntervalSlots(framework, "dwt")
                              framework <- PrepareIntervalSlots(framework, "cwt")
                            }
                            return(framework)
}



#' Get expected values
#'
#' Compute expected values from specific time intervals.
#' @param framework An analysis environment generated by \link[WaveletPhysiology]{BuildStructure}
#' @param a_index An index indicating which analysis slot needs to be used
#' @param t_index An index indicating which time inerval is to be used
#' @param time_flags A vector containing the minimum and maximum limits of a time interval, in minutes.
#'                   Default is NULL.
#' @param method From which transfer function are the estimates to be computed, either cwt, dwt or both.
#'              The default is both.
#' @param use_name Boolean, should the names of the subjects be used?
#'
#' @return The original framework with new computed estimates.
#'
#' @author Alvaro Chao-Ecija
#'
#'
#' @export
#'
#' @examples
#' # ADD EXAMPLE!
GetExpectedValues <- function(framework, a_index, t_index, time_flags,
   method = c("both", "dwt", "cwt"), use.name = TRUE){
                   method <- match.arg(method)
                   if(method == "both"){
                      framework <- AddExpectedValues(framework, a_index, t_index, time_flags,
                         method = "dwt", use.name)
                      framework <- AddExpectedValues(framework, a_index, t_index, time_flags,
                         method = "cwt", use.name)
                   } else {
                      framework <- AddExpectedValues(framework, a_index, t_index, time_flags,
                         method = method, use.name)
                   }
                   #framework <- AddTimeValues(framework, a_index, t_index, time_flags,
                   #    use.name)
                   if(method != "cwt") framework <- AddExpectedHRV(framework, a_index, t_index)
                   return(framework)
}



#' @export
PlotIndexesFromAnalysis <- function(framework, index, method = c("dwt", "cwt"),
            use.names = TRUE, HFcol = "black", LFcol = "grey", restrict = NULL,
               output = FALSE, ymax = NULL, tem = FALSE, newPlot  = TRUE){
                   if(newPlot) x11(title = paste("Estimates from",
                      framework$Analyses[[index]]$Name))
                   #if(dev.cur() > 1) dev.off()
                   intervals <- framework$ExpectedVals
                   N <- length(intervals)
                   indexes <- 1:N
                   if(!is.null(restrict)){
                      indexes <- restrict
                   }
                   results <- matrix(0, nrow = 2, ncol = NROW(indexes))
                   rownames(results) <- c("HF", "LF")
                   colnames(results) <- indexes
                   method <- match.arg(method)
                   for(n in indexes){
                         pos <- match(n, indexes)
                      if(method == "dwt"){
                         results[,pos] <- intervals[[n]]$DWT[,index]
                         title <- "Transfer Function Gains by DWT"
                      } else if(method == "cwt"){
                         results[,pos] <- intervals[[n]]$CWT[,index]
                         title <- "Transfer Function Gains by CWT"
                      }
                      if(use.names & !is.null(intervals[[n]]$Name)){
                         colnames(results)[pos] <- intervals[[n]]$Name
                      } else {
                         colnames(results)[pos] <- intervals[[n]]$Index
                      }
                   }
                   if(is.null(ymax)){
                      ylim <- NULL
                   } else {
                      ylim <- c(0, ymax)
                   }
                   if(tem){
                     im <- tempfile(fileext = ".png")
                     png(filename = im, width = 6, height = 6, units = "in", res = 400)
                   }
                   barplot(results, beside = TRUE, col = c(HFcol, LFcol),
                     ylab = "Gain (ms/mmHg)", main = title, ylim = ylim)
                   if(output & !tem){
                     return(results)
                   } else if(output & tem){
                     dev.off()
                     return(list(results = results, temp = im))
                   } else if(tem){
                     dev.off()
                     return(im)
                   }
}

#' @export
PlotTimeValues <- function(framework, index,
            use.names = TRUE, HRcol = "grey20", SBPcol = "grey80", restrict = NULL,
               output = FALSE, ymax = NULL, tem = FALSE, newPlot  = TRUE){
                   if(newPlot) x11(title = paste("Time values from",
                      framework$Analyses[[index]]$Name))
                   intervals <- framework$ExpectedVals
                   N <- length(intervals)
                   indexes <- 1:N
                   if(!is.null(restrict)){
                      indexes <- restrict
                   }
                   HR <- SBP <- double(NROW(indexes))
                   for(n in 1:NROW(indexes)){
                       HR[n] <- intervals[[indexes[n]]]$HR[1,index]
                       SBP[n] <- intervals[[indexes[n]]]$SBP[1,index]
                   }
                   results <- cbind(HR = HR, SBP = SBP)
                   rownames(results) <- double(NROW(indexes))
                   for(n in indexes){
                      pos <- match(n, indexes)
                      if(use.names & !is.null(intervals[[n]]$Name)){
                         rownames(results)[pos] <- intervals[[n]]$Name
                      } else {
                         rownames(results)[pos] <- intervals[[n]]$Index
                      }
                   }
                   if(is.null(ymax)){
                      ylim <- NULL
                   } else {
                      ylim <- c(0, ymax)
                   }
                   if(tem){
                     im <- tempfile(fileext = ".png")
                     png(filename = im, width = 6, height = 3, units = "in", res = 400)
                   }
                   results <- t(results)
                   par(mfrow = c(1,2))
                   barplot(results[1,], beside = TRUE, col = HRcol,
                      ylab = "HR (bpm)", main = "HR", ylim = ylim)
                   barplot(results[2,], beside = TRUE, col = SBPcol,
                      ylab = "SBP (mmHg)", main = "SBP", ylim = ylim)
                   if(output & !tem){
                     return(results)
                   } else if(output & tem){
                     dev.off()
                     return(list(results = results, temp = im))
                   } else if(tem){
                     dev.off()
                     return(im)
                   }
}

#' @export
TestSegments <- function(framework, a_index, time_flags, time_flags2 = NULL, name = NULL, method = c("dwt", "cwt"),
                         use.names = TRUE, sig = 0.05){
  #interval <- framework$ExpectedVals[[index1]]
  method = match.arg(method)
  Data <- framework$"General Data"
  Analysis <- framework$Analyses[[a_index]]
  if(method == "dwt"){
    tf <- Analysis$BRS$DWT
    tf$Time <- Analysis$Data[,1]
    tf$type <- "TFun_dwt"
  } else if(method == "cwt"){
    tf <- AssembleCwtTransferFun(framework, a_index)
    tf$type <- "TFun_cwt"
  }
}


#' @export
TestGroups <- function(framework, index1, index2, name = NULL, method = NULL,
   paired = NULL, type = c("dwt", "cwt"), use.names = TRUE, sig = 0.05){
              N <- length(framework$Tests)
              length(framework$Tests) <- N + 1
              EVals <- framework$ExpectedVals
              Names <- double(2)
              EVals1 <- framework$ExpectedVals[[index1]]
              EVals2 <- framework$ExpectedVals[[index2]]
              if(use.names & !is.null(EVals1$Name)){
                 Names[1] <- EVals1$Name
              } else {
                 Names[1] <- EVals1$Index
              }
              if(use.names & !is.null(EVals2$Name)){
                 Names[2] <- EVals2$Name
              } else {
                 Names[2] <- EVals2$Index
              }
              Indexes <- c(EVals1$Index, EVals2$Index)
              type <- match.arg(type)
              if(type == "dwt"){
                 values1 <- EVals1$DWT
                 values2 <- EVals2$DWT
              } else if(type == "cwt"){
                 values1 <- EVals1$CWT
                 values2 <- EVals2$CWT
              }
              names1 <- colnames(values1)
              names2 <- colnames(values2)
              bool <- names1 == names2
              if((FALSE %in% bool) & (TRUE %in% bool)){
                 stop("Mixed data cannot be tested")
              }
              if(is.null(paired)){
                 if(FALSE %in% bool){
                    paired <- FALSE
                 } else {
                    paired <- TRUE
                 }
              }
              gains_hf1 <- values1[1,]
              gains_hf2 <- values2[1,]
              gains_lf1 <- values1[2,]
              gains_lf2 <- values2[2,]
              se_hf1 <- sd(gains_hf1) / sqrt(NROW(gains_hf1))
              se_hf2 <- sd(gains_hf2) / sqrt(NROW(gains_hf2))
              se_lf1 <- sd(gains_lf1) / sqrt(NROW(gains_lf1))
              se_lf2 <- sd(gains_lf2) / sqrt(NROW(gains_lf2))
              HF <- data.frame(Group = c(rep(as.character(Names[1]), NROW(names1)),
                 rep(as.character(Names[2]), NROW(names2))), Gain = c(gains_hf1,
                     gains_hf2), Mean = c(rep(mean(gains_hf1), NROW(names1)), rep(mean(gains_hf2),NROW(names2))),
                       SE = c(rep(se_hf1, NROW(names1)), rep(se_hf2,NROW(names2))))
              LF <- data.frame(Group = c(rep(as.character(Names[1]), NROW(names1)),
                 rep(as.character(Names[2]), NROW(names2))), Gain = c(gains_lf1,
                     gains_lf2), Mean = c(rep(mean(gains_lf1), NROW(names1)), rep(mean(gains_lf2),NROW(names2))),
                       SE = c(rep(se_lf1, NROW(names1)), rep(se_lf2,NROW(names2))))
              if(is.null(method)){
                 n_hf1 <- shapiro.test(gains_hf1)$p.value
                 n_hf2 <- shapiro.test(gains_hf2)$p.value
                 n_lf1 <- shapiro.test(gains_lf1)$p.value
                 n_lf2 <- shapiro.test(gains_lf2)$p.value
                 if((n_hf1 > sig) & (n_hf2 > sig)){
                    m_hf <- "t.test"
                 } else {
                    m_hf <- "wilcox.test"
                 }
                 if((n_lf1 > sig) & (n_lf2 > sig)){
                    m_lf <- "t.test"
                 } else {
                    m_lf <- "wilcox.test"
                 }
              } else {
                 m_hf <- m_lf <- method
              }
              if(m_hf == "t.test"){
                 hf_test <- t.test(gains_hf1, gains_hf2, paired = paired)$p.value
              } else {
                 hf_test <- wilcox.test(gains_hf1, gains_hf2, paired = paired)$p.value
              }
              if(m_lf == "t.test"){
                 lf_test <- t.test(gains_lf1, gains_lf2, paired = paired)$p.value
              } else {
                 lf_test <- wilcox.test(gains_lf1, gains_lf2, paired = paired)$p.value
              }
              output <- list()
              if(is.null(name)) name <- paste("Test", N + 1)
              output$Name <- name
              output$Index <- N + 1
              output$Variables <- Names
              output$Locators <- Indexes
              output$Type <- type
              output$Tables <- list()
              output$Tables$HF <- HF
              output$Tables$LF <- LF
              output$Methods <- c(m_hf, m_lf)
              output$Paired <- paired
              output$Results <- list()
              output$Results$HF <- hf_test
              output$Results$LF <- lf_test
              framework$Tests[[N + 1]] <- output
              return(framework)
}



#' @export
TestHRV <- function(framework, index1, index2, name = NULL, method = NULL,
                       paired = NULL, use.names = TRUE, sig = 0.05, normalize = FALSE){
  N <- length(framework$TestsHRV)
  length(framework$TestsHRV) <- N + 1
  EVals <- framework$ExpectedVals
  Names <- double(2)
  EVals1 <- framework$ExpectedVals[[index1]]
  EVals2 <- framework$ExpectedVals[[index2]]
  if(use.names & !is.null(EVals1$Name)){
    Names[1] <- EVals1$Name
  } else {
    Names[1] <- EVals1$Index
  }
  if(use.names & !is.null(EVals2$Name)){
    Names[2] <- EVals2$Name
  } else {
    Names[2] <- EVals2$Index
  }
  Indexes <- c(EVals1$Index, EVals2$Index)
  values1 <- EVals1$HRV
  values2 <- EVals2$HRV
  names1 <- colnames(values1)
  names2 <- colnames(values2)
  bool <- names1 == names2
  if((FALSE %in% bool) & (TRUE %in% bool)){
    stop("Mixed data cannot be tested")
  }
  if(is.null(paired)){
    if(FALSE %in% bool){
      paired <- FALSE
    } else {
      paired <- TRUE
    }
  }
  gains_hf1 <- values1[1,]
  gains_hf2 <- values2[1,]
  gains_lf1 <- values1[2,]
  gains_lf2 <- values2[2,]
  if(normalize){
    gains1 <- gains_hf1 + gains_lf1
    gains2 <- gains_hf2 + gains_lf2
    gains_hf1 <- gains_hf1 * 100 / gains1
    gains_lf1 <- gains_lf1 * 100 / gains1
    gains_hf2 <- gains_hf2 * 100 / gains2
    gains_lf2 <- gains_lf2 * 100 / gains2
  }
  gains_lfhf1 <- values1[3,]
  gains_lfhf2 <- values2[3,]
  se_hf1 <- sd(gains_hf1) / sqrt(NROW(gains_hf1))
  se_hf2 <- sd(gains_hf2) / sqrt(NROW(gains_hf2))
  se_lf1 <- sd(gains_lf1) / sqrt(NROW(gains_lf1))
  se_lf2 <- sd(gains_lf2) / sqrt(NROW(gains_lf2))
  se_lfhf1 <- sd(gains_lfhf1) / sqrt(NROW(gains_lfhf1))
  se_lfhf2 <- sd(gains_lfhf2) / sqrt(NROW(gains_lfhf2))
  HF <- data.frame(Group = c(rep(as.character(Names[1]), NROW(names1)),
                             rep(as.character(Names[2]), NROW(names2))), Power = c(gains_hf1,
                                                                                  gains_hf2), Mean = c(rep(mean(gains_hf1), NROW(names1)), rep(mean(gains_hf2),NROW(names2))),
                   SE = c(rep(se_hf1, NROW(names1)), rep(se_hf2,NROW(names2))))
  LF <- data.frame(Group = c(rep(as.character(Names[1]), NROW(names1)),
                             rep(as.character(Names[2]), NROW(names2))), Power = c(gains_lf1,
                                                                                  gains_lf2), Mean = c(rep(mean(gains_lf1), NROW(names1)), rep(mean(gains_lf2),NROW(names2))),
                   SE = c(rep(se_lf1, NROW(names1)), rep(se_lf2,NROW(names2))))
  LFHF <- data.frame(Group = c(rep(as.character(Names[1]), NROW(names1)),
                               rep(as.character(Names[2]), NROW(names2))),Power = c(gains_lfhf1,
                                                                                    gains_lfhf2), Mean = c(rep(mean(gains_lfhf1), NROW(names1)), rep(mean(gains_lfhf2),NROW(names2))),
                     SE = c(rep(se_lfhf1, NROW(names1)), rep(se_lfhf2,NROW(names2))))
  if(is.null(method)){
    n_hf1 <- shapiro.test(gains_hf1)$p.value
    n_hf2 <- shapiro.test(gains_hf2)$p.value
    n_lf1 <- shapiro.test(gains_lf1)$p.value
    n_lf2 <- shapiro.test(gains_lf2)$p.value
    n_lfhf1 <- shapiro.test(gains_lfhf1)$p.value
    n_lfhf2 <- shapiro.test(gains_lfhf2)$p.value
    if((n_hf1 > sig) & (n_hf2 > sig)){
      m_hf <- "t.test"
    } else {
      m_hf <- "wilcox.test"
    }
    if((n_lf1 > sig) & (n_lf2 > sig)){
      m_lf <- "t.test"
    } else {
      m_lf <- "wilcox.test"
    }
    if((n_lfhf1 > sig) & (n_lfhf2 > sig)){
      m_lfhf <- "t.test"
    } else {
      m_lfhf <- "wilcox.test"
    }
  } else {
    m_hf <- m_lf <- m_lfhf <- method
  }
  if(m_hf == "t.test"){
    hf_test <- t.test(gains_hf1, gains_hf2, paired = paired)$p.value
  } else {
    hf_test <- wilcox.test(gains_hf1, gains_hf2, paired = paired)$p.value
  }
  if(m_lf == "t.test"){
    lf_test <- t.test(gains_lf1, gains_lf2, paired = paired)$p.value
  } else {
    lf_test <- wilcox.test(gains_lf1, gains_lf2, paired = paired)$p.value
  }
  if(m_lfhf == "t.test"){
    lfhf_test <- t.test(gains_lfhf1, gains_lfhf2, paired = paired)$p.value
  } else {
    lfhf_test <- wilcox.test(gains_lfhf1, gains_lfhf2, paired = paired)$p.value
  }
  output <- list()
  if(is.null(name)) name <- paste("Test", N + 1)
  output$Name <- name
  output$Index <- N + 1
  output$Variables <- Names
  output$Locators <- Indexes
  output$Tables <- list()
  output$Tables$HF <- HF
  output$Tables$LF <- LF
  output$Tables$LFHF <- LFHF
  output$Methods <- c(m_hf, m_lf, m_lfhf)
  output$Paired <- paired
  output$Results <- list()
  output$Results$HF <- hf_test
  output$Results$LF <- lf_test
  output$Results$HF <- hf_test
  output$Results$LFHF <- lfhf_test
  framework$TestsHRV[[N + 1]] <- output
  return(framework)
}





#' @export
PlotTestResults <- function(framework, index, tem = FALSE, newPlot = FALSE, draw_paired = FALSE){
  test <- framework$Tests[[index]]
  if(newPlot) x11(title = paste("Results from test",
                                test$Name))
  HF <- test$Tables$HF
  LF <- test$Tables$LF
  max_HF <- max(test$Tables$HF[,3]) + max(test$Tables$HF[,4])
  max_LF <- max(test$Tables$LF[,3]) + max(test$Tables$LF[,4])
  Max = max(max_HF, max_LF)
  paired <- test$Paired
  methods <- test$Methods
  type <- test$Type
  if(type == "dwt"){
    title <- "Transfer Function by DWT"
  } else {
    title <- "Transfer Function by CWT"
  }
  comparisons <- list(test$Variables)
  if(paired) HF$id <- LF$id <- rep(1:framework$n, 2)
  par(mfrow = c(1,2))
  if(tem){
    im <- tempfile(fileext = ".png")
    png(filename = im, width = 6.2, height = 6, units = "in", res = 400)
  }
  plot1 <- ggplot2::ggplot(HF, ggplot2::aes(Group, Gain, fill = Group)) +
    ggplot2::geom_boxplot() +
    ggplot2::theme_bw() +
    ggpubr::stat_compare_means(ggplot2::aes(Group, Gain), comparisons = comparisons,
                               symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1),
                                                  symbols = c("****", "***", "**", "*", "NS")), method = methods[1],
                               paired = paired, label.y = max_HF) +
    ggplot2::ggtitle(paste(title, "(HF)"))
  if(paired & draw_paired) plot1 <- plot1 + ggplot2::geom_point() + ggplot2::geom_line(ggplot2::aes(group = id))
  plot2 <- ggplot2::ggplot(LF, ggplot2::aes(Group, Gain, fill = Group)) +
    ggplot2::geom_boxplot() +
    ggplot2::theme_bw() +
    ggpubr::stat_compare_means(ggplot2::aes(Group, Gain), comparisons = comparisons,
                               symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1),
                                                  symbols = c("****", "***", "**", "*", "NS")), method = methods[2],
                               paired = paired, label.y = max_LF) +
    ggplot2::ggtitle(paste(title, "(LF)"))
  if(paired & draw_paired) plot2 <- plot2 + ggplot2::geom_point() + ggplot2::geom_line(ggplot2::aes(group = id))
  gridExtra::grid.arrange(plot1, plot2, ncol = 2)
  if(tem){
    dev.off()
    return(im)
  }
}


#' @export
PlotHRVTestResults <- function(framework, index, tem = FALSE, newPlot = FALSE, draw_paired = FALSE){
  test <- framework$TestsHRV[[index]]
  if(newPlot) x11(title = paste("Results from test",
                                test$Name))
  HF <- test$Tables$HF
  LF <- test$Tables$LF
  LFHF <- test$Tables$LFHF
  max_HF <- max(test$Tables$HF[,3]) + max(test$Tables$HF[,4])
  max_LF <- max(test$Tables$LF[,3]) + max(test$Tables$LF[,4])
  max_LFHF <- max(test$Tables$LFHF[,3]) + max(test$Tables$LFHF[,4])
  min_LFHF <- min(min(test$Tables$LFHF[,3]), min(test$Tables$LFHF[,4]))
  Max = max(max_HF, max_LF)
  paired <- test$Paired
  methods <- test$Methods
  title <- "HRV"
  comparisons <- list(test$Variables)
  if(paired) HF$id <- LF$id <- LFHF$id <- rep(1:framework$n, 2)
  par(mfrow = c(1,3))
  if(tem){
    im <- tempfile(fileext = ".png")
    png(filename = im, width = 6.2, height = 6, units = "in", res = 400)
  }
  plot1 <- ggplot2::ggplot(HF, ggplot2::aes(Group, Power, fill = Group)) +
    ggplot2::geom_boxplot() +
    ggplot2::theme_bw() +
    ggpubr::stat_compare_means(ggplot2::aes(Group, Power), comparisons = comparisons,
                               symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1),
                                                  symbols = c("****", "***", "**", "*", "NS")), method = methods[1],
                               paired = paired, label.y = max_HF) +
    ggplot2::ggtitle(paste(title, "(HF)"))
  if(paired & draw_paired) plot1 <- plot1 + ggplot2::geom_point() + ggplot2::geom_line(ggplot2::aes(group = id))
  plot2 <- ggplot2::ggplot(LF, ggplot2::aes(Group, Power, fill = Group)) +
    ggplot2::geom_boxplot() +
    ggplot2::theme_bw() +
    ggpubr::stat_compare_means(ggplot2::aes(Group, Power), comparisons = comparisons,
                               symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1),
                                                  symbols = c("****", "***", "**", "*", "NS")), method = methods[2],
                               paired = paired, label.y = max_LF) +
    ggplot2::ggtitle(paste(title, "(LF)"))
  if(paired & draw_paired) plot2 <- plot2 + ggplot2::geom_point() + ggplot2::geom_line(ggplot2::aes(group = id))
  plot3 <- ggplot2::ggplot(LFHF, ggplot2::aes(Group, Power, fill = Group)) +
    ggplot2::geom_boxplot() +
    ggplot2::theme_bw() +
    ggpubr::stat_compare_means(ggplot2::aes(Group, Power), comparisons = comparisons,
                               symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1),
                                                  symbols = c("****", "***", "**", "*", "NS")), method = methods[2],
                               paired = paired, label.y = max_LF) +
    ggplot2::ggtitle(paste(title, "(LF/HF)"))
  if(paired & draw_paired) plot3 <- plot3 + ggplot2::geom_point() + ggplot2::geom_line(ggplot2::aes(group = id))
  gridExtra::grid.arrange(plot1, plot2, plot3, ncol = 3)
  if(tem){
    dev.off()
    return(im)
  }
}

#' @export
ModelClinicalData <- function(framework, type = c("BRS", "HRV"), band = c("HF", "LF", "LFHF"), segment = 1, variable = 1, use.names = TRUE){
  EVals <- framework$ExpectedVals[[segment]]
  type <- match.arg(type)
  band <- match.arg(band)
  if(use.names & !is.null(EVals$Name)){
    Names <- EVals$Name
  } else {
    Names <- EVals$Index
  }
  Indexes <- c(EVals1$Index, EVals2$Index)
  if(type == "HRV"){
    values <- EVals$HRV
    unit2 <- "ms2"
  } else {
    values <- EVals$DWT
    unit2 <- "ms/mmHg"
  }
  if(band == "HF") values <- values[1,]
  if(band == "LF") values <- values[2,]
  if(band == "LFHF" && type == "HRV") values <- values[3,]
  clin <- framework$Clinical
  clin <- clin[,variable + 1]
  units <- clin[1]
  clin <- as.numeric(clin[-1])
  model <- lm(values ~ clin)
  r <- summary(model)$r.squared
  p <- summary(model)$coefficients[2,4]
  data <- data.frame(values = values, clinical = clin)
  Plot <- ggplot2::ggplot(data, ggplot2::aes(clinical, values)) +
    ggplot2::geom_point() + ggplot2::geom_smooth(method = "lm", color = "red") +
     ggplot2::theme_minimal() + ggplot2::labs(y = paste(type, " (", band, " band, ", unit2, ")", sep = ""),
                                             x = paste(names(framework$Clinical)[variable + 1], " (",
                                                       framework$Clinical[1, variable + 1], ")", sep = ""))
  output <- list(r = r, p = p, Plot = Plot)
  return(output)
}





# Auxiliar Functions:

#' @export
ExtractDataFromAnalysis <- function(framework, index){
          Data <- framework$"General Data"
          Data$Data <- framework$Analyses[[index]]$Data
          return(Data)
}



AddTFtoAnalysis <- function(framework, tf, index){
           if(tf$type == "TFun_dwt"){
              tf$type <- NULL
              tf$Time <- NULL
              hrv <- tf$HRV
              tf$HRV <- NULL
              framework$Analyses[[index]]$BRS$DWT <- tf
              framework$Analyses[[index]]$HRV <- hrv
           } else if(tf$type == "TFun_cwt"){
              tf$type <- NULL
              tf$VLF <- NULL
              tf$LF <- NULL
              tf$HF <- NULL
              tf$Time <- NULL
              framework$Analyses[[index]]$BRS$CWT <- tf
           }
           return(framework)
}

AssembleCwtTransferFun <- function(framework, index){
                  Data <- framework$"General Data"
                  TFun <- framework$Analyses[[index]]$BRS$CWT
                  TFun$HF <- Data$HF
                  TFun$LF <- Data$LF
                  TFun$VLF <- Data$VLF
                  TFun$Time <- framework$Analyses[[index]]$Data[,1]
                  return(TFun)
}

AddExpectedValues <- function(framework, a_index, t_index, time_flags,
   method = c("dwt", "cwt"), use.name = TRUE){
                   interval <- framework$ExpectedVals[[t_index]]
                   method = match.arg(method)
                   Data <- framework$"General Data"
                   Analysis <- framework$Analyses[[a_index]]
                   if(method == "dwt"){
                          tf <- Analysis$BRS$DWT
                          tf$Time <- Analysis$Data[,1]
                          tf$type <- "TFun_dwt"
                          others <- interval$DWT
                          Time <- framework$ExpectedVals[[t_index]]$Time_DWT
                          N <- length(others)
                   } else if(method == "cwt"){
                          tf <- AssembleCwtTransferFun(framework, a_index)
                          tf$type <- "TFun_cwt"
                          others <- interval$CWT
                          Time <- framework$ExpectedVals[[t_index]]$Time_CWT
                          N <- length(others)
                   }
                   EVals <- ExpectedValues(tf, time_flags,
                      weight = interval$Weight, use.coherence = interval$Threshold,
                         thr <- Data$Coherence)
                   if(N == 0){
                      results <- matrix(EVals, nrow = 2, ncol  =1)
                      rownames(results) <- c("HF", "LF")
                      n <- 1
                      Time <- matrix(AdjustTime(tf, time_flags), nrow = 2, ncol  =1)
                   } else if(a_index <= ncol(others)){
                     results <- others
                     results[,a_index] <- EVals
                     Time[,a_index] <- AdjustTime(tf, time_flags)
                   } else {
                      results <- cbind(others, EVals)
                      n <- ncol(results)
                      Time <- cbind(Time, AdjustTime(tf, time_flags))
                   }
                   if(use.name & !is.null(Analysis$Name)){
                         colnames(results)[a_index] <- Analysis$Name
                   } else {
                         colnames(results)[a_index] <- Analysis$Index
                   }
                   if(method == "dwt"){
                          framework$ExpectedVals[[t_index]]$DWT <- results
                          framework$ExpectedVals[[t_index]]$Time_DWT <- Time
                   } else if(method == "cwt"){
                          framework$ExpectedVals[[t_index]]$CWT <- results
                          framework$ExpectedVals[[t_index]]$Time_CWT <- Time
                   }
                   return(framework)
}



AddExpectedHRV <- function(framework, a_index, t_index, use.name = TRUE){
  interval <- framework$ExpectedVals[[t_index]]
  others <- interval$HRV
  Names <- colnames(interval$DWT)
  N <- length(others)
  Data <- framework$"General Data"
  Analysis <- framework$Analyses[[a_index]]
  Time <- Analysis$Data[,1]
  time_flags <- framework$ExpectedVals[[t_index]]$Time_DWT
  hrv <- Analysis$HRV
  time_flags <- time_flags * 60
  select_time <- Time[(Time >= time_flags[1]) &
                            (Time <= time_flags[2])]
  select_time <- match(select_time, Time)
  for(n in 1:length(hrv)) hrv[[n]] <- mean(hrv[[n]][select_time])
  hrv <- rbind(hrv[[1]], hrv[[2]], hrv[[3]])
  if(N == 0){
    rownames(hrv) <- c("HF", "LF", "LFHF")
  } else if(a_index <= ncol(others)){
    results <- others
    results[,a_index] <- hrv
    hrv <- results
  } else {
    hrv <- cbind(others, hrv)
  }
  if(use.name) colnames(hrv)[a_index] <- Names[a_index]
  framework$ExpectedVals[[t_index]]$HRV <- hrv
  return(framework)
}


PrepareIntervalSlots <- function(framework, method = c("dwt", "cwt")){
  n <- framework$n
  method <- match.arg(method)
  for(m in 1:length(framework$ExpectedVals)){
    if(method == "dwt"){
      int <- framework$ExpectedVals[[m]]$DWT
      Time <- framework$ExpectedVals[[m]]$Time_DWT
    } else {
      int <- framework$ExpectedVals[[m]]$CWT
      Time <- framework$ExpectedVals[[m]]$Time_CWT
    }
    if(length(int) == 0 || is.null(int[[1]])){
      int <- Time <- matrix(NA, ncol = n, nrow = 2)
      colnames(int) <- rep("Unnamed", n)
    } else if(n > ncol(int)){
      cols <- n - ncol(int)
      names <- colnames(int)
      support <- matrix(NA, ncol = cols, nrow = 2)
      int <- cbind(int, support)
      Time <- cbind(Time, support)
      colnames(int) <- c(names, rep("Unnamed", cols))

    }
    if(method == "dwt"){
      framework$ExpectedVals[[m]]$DWT <- int
      framework$ExpectedVals[[m]]$Time_DWT <- Time
    } else {
      framework$ExpectedVals[[m]]$CWT <- int
      framework$ExpectedVals[[m]]$Time_CWT <- Time
    }
  }
  return(framework)
}




AddTimeValues <- function(framework, a_index, t_index, time_flags,
  use.name = TRUE){
                   interval <- framework$ExpectedVals[[t_index]]
                   Analysis <- framework$Analyses[[a_index]]
                   HR <- interval$HR
                   SBP <- interval$SBP
                   TimeValues <- TimeDomainValues(Analysis$Data, time_flags)
                   n = length(HR)
                   if(length(HR) == 0){
                      HR <- matrix(TimeValues$HR, 2, 1)
                      SBP <- matrix(TimeValues$SBP, 2, 1)
                   } else if(a_index <= ncol(HR)){
                     HR[,a_index] <- TimeValues$HR
                     SBP[,a_index] <- TimeValues$SBP
                   } else {
                      HR <- cbind(HR, TimeValues$HR)
                      SBP <- cbind(SBP, TimeValues$SBP)
                   }
                   if(use.name & !is.null(Analysis$Name)){
                         colnames(HR)[a_index] <- Analysis$Name
                         colnames(SBP)[a_index] <- Analysis$Name
                   } else {
                         colnames(HR)[a_index] <- Analysis$Index
                         colnames(SBP)[a_index] <- Analysis$Index
                   }
                   framework$ExpectedVals[[t_index]]$HR <- HR
                   framework$ExpectedVals[[t_index]]$SBP <- SBP
                   return(framework)
}


AdjustTime <- function(fun, time_flags = NULL){
  if(is.null(time_flags)){
    select_time <- 1:NROW(fun$Time)
  } else {
    time_flags <- time_flags * 60
    select_time <- fun$Time[(fun$Time >= time_flags[1]) &
                              (fun$Time <= time_flags[2])]
    select_time <- match(select_time, fun$Time)
  }
  return(c(min(fun$Time[select_time]/60), max(fun$Time[select_time]/60)))
}



GetAvgCwtBands <- function(fun, thr = 0.5, use.thr = TRUE, scale = 1,
         time_flags = NULL, len = 7, HFcolor = "yellow", LFcolor = "green",
         Tcolor = "brown", tem  =FALSE){
  HF <- fun$HF
  LF <- fun$LF
  VLF <- fun$VLF
  fun <- GetBiwaveletObject(fun)
  freqs <- 1/fun$period
  sel_power <- fun$power
  min_freqs <- min(freqs)
  max_freqs <- max(freqs)
  if(max_freqs > HF) max_freqs <- HF
  if(min_freqs < VLF) min_freqs <- VLF
  time_results.HF <- colMeans(fun$power[(freqs <= HF) & (freqs > LF),],
                              na.rm = TRUE)
  time_results.LF <- colMeans(fun$power[(freqs <= LF) & (freqs > VLF),],
                              na.rm = TRUE)
  return(list(HF = time_results.HF, LF = time_results.LF))

}




