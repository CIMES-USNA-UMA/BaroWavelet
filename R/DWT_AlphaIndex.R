#' Discrete Wavelet Transform Transfer Function
#'
#' Computes baroreflex sensitivity as a transfer function suing the Discrete Wavelet Transform
#' @param data A matrix with 3 columns containing time values (first column), RR and SBP values (second
#'             and third column).
#' @param HF Maximum limit of the HF band. Default is 0.4 Hz
#' @param LF Maximum limit of the LF band. Default is 0.15 Hz
#' @param VLF Maximum limit of the VLF band. Default is 0.04 Hz
#' @param wv A wavelet for the analysis. Default is d4
#' @param hrv Boolean, should the heart rate variability results be returned too? Default is FALSE
#' @param error Tolerance for the PMODWPT. Default is 0.01
#' @param error.type Type of tolerance (absolute or relative) for the PMODWPT
#'
#' @return A list with the estimated components of the baroreflex transfer function in the wavelet domain:
#' \item{HF}{The computed vector of alpha indices for the HF band}
#' \item{LF}{The computed vector of alpha indices for the LF band}
#' \item{VLF}{The chosen maximum limit of the VLF band}
#' \item{Time}{The original vector of time values}
#' \item{type}{A character string specifying which type of BRS has been computed}
#' \item{hrv}{A list containing the variability results computed at the HF and LF bands, as well as the
#'            LF/HF ratio. Only returned if the hrv argument is set to TRUE}
#'
#' @details This function works in the following way: first the variables are adapted so that they can be
#' processed by the \href{https://CRAN.R-project.org/package=RHRV}{RHRV} package. This is done by creating structures similar to the one generated by
#' RHRV function \code{link[RHRV]{CreateHRVData}}, which are then filled by RR and BP data and can be recognized by RHRV. Then, this function sends the variables to the RHRV functions so that their variability
#' can be calculated using the Pruned-MODWT(PMODWT), an algorithm introduced in the RHRV package (see the reference
#' section for more details regarding package RHRV and the PMODWT algorithm or check the RHRV function \code{link[RHRV]{CalculatePowerBand}}). The obtained variability results are then used
#' to calculate a time-varying alpha index representative of the baroreflex sensitivity at the HF and LF bands.
#' Also, the function is able to return the computed heart variability results by \href{https://CRAN.R-project.org/package=RHRV}{RHRV} package.
#' @author Alvaro Chao-Ecija
#' @references
#' Rodriguez-Linares L, Mendez AJ, Lado MJ, Olivieri DN, Vila XA, Gomez-Conde I. 
#' An open source tool for heart rate variability spectral analysis. Comput Methods 
#' Programs Biomed. 2011;103(1):39-50.
#'
#' Garcia Martinez CA, Otero Quintana A, Vila XA, Lado Tourino MJ, Rodriguez-Linares L, 
#' Rodriguez Presedo JM, Mendez Penin AJ. Heart Rate Variability Analysis with the R package 
#' RHRV. Cham: Springer International Publishing; 2017. 
#'
#' Garcia CA, Otero A, Vila X, Marquez DG. A new algorithm for wavelet-based heart 
#' rate variability analysis. Biomed Signal Process Control. 2013;8(6):542-50.
#'
#' A Chao-Ecija , MS Dawid-Milner , BaroWavelet: An R-based tool for dynamic 
#' baroreflex evaluation through wavelet analysis techniques, Computer Methods 
#' and Programs in Biomedicine (2023), doi: https://doi.org/10.1016/j.cmpb.2023.107758
#'
#' @import RHRV
#' @export
#'
#' @examples
#' Data <- InterpolateData(DataSimulation(), f = 1)
#' AlphaIndex <- AlphaIndexDWT(Data, wv = "d8", error = 0.0005)

AlphaIndexDWT <- function(data,
                          HF = 0.4,
                          LF = 0.15,
                          VLF = 0.04,
                          wv = "d4",
                          hrv = FALSE,
                          error = 0.01,
                          error.type = c("absolute", "relative")) {
  if (!is.data.frame(data))
    data <- as.data.frame(data)
  error.type <- match.arg(error.type)
  if(!is.numeric(error)) stop("Please provide a numeric value for the error level.")
  RHRVobjects <- GenerateRHRVObjects(data)
  RHRVobjects <-
    SendDataToRHRV(RHRVobjects, HF, LF, VLF, wv, error,
                   error.type)
  SBP_HF <- RHRVobjects$SBP$FreqAnalysis[[1]]$HF
  SBP_LF <- RHRVobjects$SBP$FreqAnalysis[[1]]$LF
  RR_HF <- RHRVobjects$RR$FreqAnalysis[[1]]$HF
  RR_LF <- RHRVobjects$RR$FreqAnalysis[[1]]$LF
  output <- list()
  output$HF <- sqrt(RR_HF / SBP_HF)
  output$HF[sqrt(SBP_HF) == 0] <- 0
  output$LF <- sqrt(RR_LF / SBP_LF)
  output$LF[sqrt(SBP_LF) == 0] <- 0
  output$Time <- data[, 1]
  output$type <- "brs_dwt"
  if (hrv) {
    output$HRV <- list()
    output$HRV$HF <- RR_HF
    output$HRV$LF <- RR_LF
    output$HRV$LFHF <- RR_LF / RR_HF
    output$HRV$HFnu <- RR_HF * 100 / (RR_HF + RR_LF)
    output$HRV$LFnu <- RR_LF * 100 / (RR_HF + RR_LF)
  }
  return(output)
}


#########################################################
# AUXILIARY FUNCTIONS                                   #
#########################################################



# Private function: generates an object with structures compatible with package RHRV,
# that is, structures based on the ones generated by the RHRV function CreateHRVData.
# These structures are automatically filled with the necessary data to perform the BRS
# analysis, and variables that serve as indicators for BaroWavelet regarding how the data
# should be processed.
GenerateRHRVObjects <- function(data) {
  RHRVobjects <- list()
  length(RHRVobjects) <- 2
  # Calls data in RHRV package to create a template.
  template <- GenerateRHRVtemplate()
  for (n in 1:2) {
    # The lists will share some elements with the ones produced by RHRV's function
    # CreateHRVData to make the data recognizable by RHRV.
    RHRVobjects[[n]] <- template
    RHRVobjects[[n]][[4]][[1]] <- data[, 1]
    RHRVobjects[[n]][[5]] <- 1 / abs(diff(data[, 1]))[1]
    # HR and SBP data is incorporated to these objects. Boolean variables tell the package how
    # the data should be processed.
    if (n == 1) {
      RHRVobjects[[n]][[6]] <- 60000 / data[, n + 1]
      RHRVobjects[[n]]$Adapt <- FALSE
    } else {
      RHRVobjects[[n]][[6]] <- NULL
      RHRVobjects[[n]]$SBP <- data[, n + 1]
      RHRVobjects[[n]]$Adapt <- TRUE
    }
  }
  names(RHRVobjects) <- c("RR", "SBP")
  return(RHRVobjects)
}


# Private function: calls example data from RHRV to create a template for a 
# compatible RHRV object.
GenerateRHRVtemplate <- function(){
  HRVProcessedData <- NULL # Added to solve note
  # Calls data in RHRV package to create a template
  data(HRVProcessedData, package = "RHRV", envir = environment()) 
  template <- HRVProcessedData
  template <- template[-c(3,4,6)]
  names_in_template4 <- names(template[[4]])
  template[[4]] <- list()
  length(template[[4]]) <- 1
  names(template[[4]]) <- names_in_template4[1]
  return(template)
}


# Private function: sends data to RHRV function CalculatePowerBand to compute the
# wavelet transform of the variables.
SendDataToRHRV <-
  function(RHRVobjects,
           HF = 0.4,
           LF = 0.15,
           VLF = 0.04,
           wv = "d4",
           error = 0.01,
           error.type = "absolute") {
    for (n in 1:2) {
      RHRVobjects[[n]] <-
        AdaptSBPtoRHRV(RHRVobjects[[n]])
      RHRVobjects[[n]] <- RHRV::CreateFreqAnalysis(RHRVobjects[[n]])
      RHRVobjects[[n]] <- RHRV::CalculatePowerBand(
        RHRVobjects[[n]],
        ULFmax = 0.003,
        VLFmin = 0.003,
        VLFmax = VLF,
        LFmin = VLF,
        LFmax = LF,
        HFmin = LF,
        HFmax = HF,
        type = "wavelet",
        wavelet = wv,
        bandtolerance = error,
        relative = (error.type == "relative")
      )
    }
    return(RHRVobjects)
  }


# Private function: transforms blood pressure data to make it compatible with the
# RHRV algorithms.
AdaptSBPtoRHRV <- function(RHRVobject) {
  if (RHRVobject$Adapt) {
    RHRVobject$HR <-  60000 / RHRVobject$SBP
  }
  return(RHRVobject)
}



